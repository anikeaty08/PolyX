ou are helping me build a full-stack Web3 application called PolyX.

PolyX is a Twitter-like social network deployed on Polygon Amoy testnet, where:

Users can post tweets, like, retweet, and quote-tweet.

All core actions are recorded on-chain.

Users do not pay gas.

The backend uses a developer-owned wallet to send and pay for all on-chain transactions.

We are not using Biconomy or external gasless infra. We use a custom relayer.

I want you to think from both user perspective and developer perspective, and design the entire system (contracts, backend, frontend, structure, envs, docs) accordingly.

1. User Perspective – How PolyX Should Feel

From a normal user’s point of view:

PolyX feels like a minimal clone of Twitter or X.

They see:

A home feed of posts (tweets) in reverse chronological order.

Each post shows the author, time, content, and action buttons (Like, Retweet, Quote).

They can:

Create a new post (tweet).

Like a post.

Retweet a post.

Quote-tweet a post (retweet with a comment).

They do not:

Worry about gas.

See raw blockchain stuff.

Need to manage MATIC for fees.

The experience should be:

Simple, clean, and easy to use.

“I type something, click Tweet, and it just appears.”

Behind the scenes, the app uses Polygon Amoy and a backend relayer to handle the blockchain.

The story to keep in mind:

“PolyX is a gasless, on-chain Twitter-style app. Everything important is written to the blockchain, but the user interface feels just like a Web2 app.”

2. Developer Perspective – High-Level Architecture

From a developer’s view, PolyX is:

A monorepo with three main parts:

contracts – smart contracts on Polygon Amoy.

backend – Node.js backend that acts as a relayer and API server.

frontend – Next.js frontend that talks to the backend.

Core principles:

All on-chain writes (post, like, retweet, quote) are triggered via the backend.

The backend uses a developer-controlled wallet to send transactions and pay gas.

Users interact only with the frontend and never directly send blockchain transactions.

Polygon Amoy RPC URL, private keys, and contract addresses must all be configurable through environment variables.

The backend acts as:

A trusted relayer.

A simple access control and rate limiter.

A single point that signs and submits transactions to Polygon Amoy.

3. Project Structure & Responsibilities

Create a structure like:

contracts/

Smart contracts and deployment scripts.

backend/

API server, relayer, business logic.

frontend/

UI for users.

At the root, include:

A clear README explaining how to set everything up.

Example environment files (.env.example) for contracts, backend, and frontend.

4. Smart Contracts – Core Data Model & Features

Design one or more contracts that handle:

Users / Profiles

Optional to keep simple:

At minimum, use Ethereum addresses as identities.

Optionally allow username / display name stored on-chain or off-chain.

You can start with basic address-based identities.

Posts (Tweets)

Every post should have:

A unique numeric ID (incremental counter).

Author address.

Text content.

Timestamp.

A reference field for:

Original post it retweets or quotes (if any).

A type or enum indicating whether it is:

an original post

a reply (optional)

a retweet

a quote-tweet

Store posts in a mapping by ID.

Emit events when posts are created for easier indexing.

Likes

Track which address liked which post.

Prevent double-likes by the same user.

Optionally enable unliking, or keep it as “like-only”.

Expose functions to query like counts or check if a user liked a post.

Retweets

Retweet is a share of an existing post.

Can be modeled either as:

A new post with type “retweet” and reference to the original post ID, or

A separate mapping of user → original post with a flag.

Emit an event when a retweet is performed.

Track retweet count per post.

Quote Tweets

Similar to retweet but with additional text.

Model as:

A new post of type “quote” that references the original post ID and includes its own message.

Emit events for easier feed reconstruction.

Read Functions / Utilities

Provide functions to:

Return basic post data by ID.

Optionally return a batch of posts for pagination.

The backend can also use events for building feeds, so the contract doesn’t have to be complex.

Design the contract(s) to be:

Clear and minimal but supporting:

Posting.

Liking.

Retweeting.

Quote-tweeting.

Optimized for testnet usage (Amoy) without overengineering.

The contract write functions will be called by the backend’s sponsor wallet, but they should take a “logical user” address as an argument so that the chain still records who the actual user is.

5. Backend – Relayer and API Design

The backend is a Node.js application in backend/ that:

Connects to Polygon Amoy via RPC.

Uses a developer-owned private key from environment variables.

Instantiates the PolyX contract(s) with that signer.

Exposes REST API endpoints for the frontend.

Environment variables should include:

Polygon Amoy RPC URL.

Sponsor wallet private key (developer account).

Deployed contract address(es).

Port for the backend server.

Core backend behaviors:

POST /api/tweet

Request body: text content and the logical user identifier (e.g., wallet address or username).

Validates content length (e.g., not empty, reasonable max length).

Creates a transaction to the contract to create a new post.

Sends the transaction from the sponsor wallet.

Waits for confirmation or at least obtains the transaction hash.

Returns status, transaction hash, and the new post ID if possible.

POST /api/like

Request body: post ID and user identifier.

Validates that the post ID exists (or at least is non-zero).

Calls the contract function for liking a post on behalf of the user.

Sponsor wallet pays gas.

Returns status and transaction hash.

POST /api/retweet

Request body: original post ID and user identifier.

Creates a transaction that registers a retweet (or creates a retweet-type post).

Sponsor wallet sends the transaction.

Returns basic info and transaction hash.

POST /api/quote

Request body: original post ID, quote text, and user identifier.

Validates:

Quote text length.

Original post ID.

Calls the contract to create a quote post referencing the original.

Sponsor wallet pays gas.

Returns status and transaction hash.

GET /api/feed

Returns a list of recent posts:

With author, text, timestamp, type (original/retweet/quote), and reference IDs.

Can use either:

Contract view functions, or

Off-chain logic based on events (depending on how you structure reads).

GET /api/post/:id

Returns detailed info for a single post:

Post content.

Author.

Number of likes.

Number of retweets.

Whether it’s a retweet or quote of another post.

Backend non-functional requirements:

Use TypeScript.

Use proper environment handling.

Include basic error handling and structured responses.

Clearly separate:

Contract interaction layer.

HTTP request handling layer.

Mention where rate limiting or authentication could be added (even if not implemented).

Remember: the backend is a trusted relayer. It signs and sends all write transactions using the sponsor wallet, so the user never has to pay gas.

6. Frontend – Next.js UI for PolyX

The frontend is a Next.js app in frontend/ that:

Talks to the backend API, not directly to the blockchain.

Provides a simple, clean experience similar to a minimal Twitter client.

Core UI elements and functionality:

Home Feed Page

Displays a list of posts with:

Author (address or username).

Content text.

Time (formatted).

Buttons for:

Like

Retweet

Quote

Fetches data from the backend’s GET /api/feed.

Compose Tweet Box

A text area at the top for composing a new post.

A “Tweet” button.

On submit, sends a POST request to backend /api/tweet with:

message

some user identifier (for now, could be a simple input or a fixed test address).

Shows basic loading and error states.

Retweet and Quote Flow

Retweet button calls backend /api/retweet.

Quote button could open a modal or separate text box for quote content, then send to /api/quote.

Like Button

On click, calls backend /api/like.

UI updates like count optimistically or after response.

User Identity

Initially, you can:

Let users type a display name or address manually.

Or later integrate a wallet connector.

Make the system simple to start, but leave room for future wallet integration.

Visual design:

Keep it minimal and clean.

It doesn’t have to look exactly like Twitter, but the structure (compose box + feed + actions per post) should feel familiar.

7. Config & Environment

For each subproject, define a .env.example file that shows which variables are required. For example:

For contracts:

Polygon Amoy RPC URL.

Deployer private key.

For backend:

Polygon Amoy RPC URL.

Sponsor wallet private key.

Contract address.

Server port.

For frontend:

Backend base URL.

In the README, clearly describe:

How to copy .env.example to .env.

Where to get a Polygon Amoy RPC URL.

How to fund the sponsor/deployer account with test MATIC.

The exact order:

Install dependencies.

Deploy contract(s).

Update backend env with contract address.

Start backend.

Start frontend.

8. Documentation

In the root README, explain in plain language:

What PolyX is.

That it’s a gasless on-chain Twitter-like app:

The user doesn’t pay gas.

The developer’s backend wallet sponsors transactions.

High-level architecture.

Commands to run each part.

Any assumptions or simplifications.

Your overall task:

Use this description to generate:

Project structure.

Smart contract design (described in comments and function names, not only code).

Backend API structure and logic behavior.

Frontend pages and component responsibilities.

Environment variable requirements.

A clear README.

Make everything understandable enough that I can follow how PolyX works from end to end.